# -*- coding: utf-8 -*-
"""cryptoa3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1r9v7-pvRRO9j5gwX7jaotsVkNcZl8h3O
"""

!pip install git+git://github.com/jameslyons/pycipher
from pycipher import SimpleSubstitution as SimpleSub
import re
import random

cipherfile = 'ciphers.txt'
cipheroriginals = {}
perms = {}
index =0
for line in file(cipherfile):
  perm, cipher = line.split(' ')
  cipheroriginals[index] = cipher
  perms[index] = perm
  #print(type(perm))
  index = index + 1

print(perms)

index_new = 0
#print(cipheroriginals[0])
while index_new<120:
  cipher_lower_form = cipheroriginals[index_new];
  
  void_string = ''
  for j in cipher_lower_form:
    void_string = void_string + j.upper()

  cipheroriginals[index_new] = void_string
  index_new=index_new + 1

print(cipheroriginals)

from math import log10

quadgrams = {}
ngramfile = 'english_quadgrams.txt'
for line in file(ngramfile):
  quadgram_key, freq = line.split(' ')
  quadgrams[quadgram_key] = int(freq)

L = len(quadgram_key)
N = sum(quadgrams.itervalues())

for val in quadgrams.keys():
  quadgrams[val] = log10(float(quadgrams[val])/N)

floor_value = log10(0.01/N)

def metric(textdata, quadgrams):
  score = 0
  for i in xrange(len(textdata)-L+1):
    if textdata[i:i+L] in quadgrams:
      score += quadgrams[textdata[i:i+L]]
    else:
      score += floor_value
  return score







def permsubsdeco(cipher, quadgrams, permutation):
  parent_key = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
  parent_score = -1e11
  best_score = parent_score
  best_key = []
  for _ in parent_key:
    best_key.append(_)
  count=0;
  found=False

  ex_iters = 10

  while ex_iters>0 :
    if(found):
      break
    count=count+1
    ex_iters=ex_iters-1
    print(ex_iters)
    random.shuffle(parent_key)
    plain_text = SimpleSub(parent_key).decipher(cipher)
    parent_score = metric(plain_text,quadgrams)
    #print(parent_score)

    iters=0

    while iters<700:
      c1 = random.randint(0,25)
      c2 = random.randint(0,25)
      new_key = []
      for _ in parent_key:
        new_key.append(_)
      temp = new_key[c1]
      new_key[c1] = new_key[c2];
      new_key[c2] = temp;
      swap_plain_text = SimpleSub(new_key).decipher(cipher)
      new_score = metric(swap_plain_text, quadgrams)
      if new_score > parent_score:
          parent_score = new_score
          parent_key = []
          for _ in new_key:
            parent_key.append(_)
          iters=0
      iters=iters+1

    if parent_score>best_score:
      best_score = parent_score
      best_key = []
      for _ in parent_key:
        best_key.append(_)


  print(SimpleSub(best_key).decipher(cipher))
  print(permutation)

nos = 0;
while nos < 120:
  cipher_text = cipheroriginals[nos]
  permutation = perms[nos]
  permsubsdeco(cipher_text, quadgrams, permutation)
  #print(permutation)
  nos = nos + 1

